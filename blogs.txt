Tricks-
http://codeforces.com/blog/entry/15643
https://codeforces.com/blog/entry/75456

https://codeforces.com/blog/entry/53925 ==>Nisiyama_Suzune's blog
he/she covers advanced maths topics

//struct with initialisation...
struct node{
    ll p0,p1,p2,p3;
    node(ll one,ll two,ll three,ll four):
        p0{one},p1{two},p2{three},p3{four} {}
    ll v[4]={p0,p1,p2,p3};
};
------------------------------------------------------------------------
order statistics tree
https://codeforces.com/blog/entry/11080
policy based data structures

#include <ext/pb_ds/assoc_container.hpp>
#define ok(x)          order_of_key(x)
#define fo(x)          find_by_order(x)
using namespace __gnu_pbds;
typedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> os;
------------------------------------------------------------------------
Seg Tree- 
https://codeforces.com/blog/entry/44478?#comment-290116
https://codeforces.com/blog/entry/44478?#comment-290057
https://codeforces.com/blog/entry/15890
interesting problems that i've solved with seg trees...
number of smaller elements in left side.
kth smaller number.
deleting elements from array cses-1749

------------------------------------------------------------------------
Perseg Tree-
https://discuss.codechef.com/t/distnum2-editorial/12566

------------------------------------------------------------------------
Rectangular Grid Walking
https://brilliant.org/wiki/rectangular-grid-walk-no-restriction/
------------------------------------------------------------------------

KMP-booth's algorithm
The Booth's algorithm uses a modified version of the KMP preprocessing function to find the lexicographically minimal string rotation. The failure function is progressively calculated as the string is rotated.

https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm#Variants

int rot(string s){
    s+=s;
    int n=s.length();
    int f[n];
    rep(i,0,n)f[i]=-1;
    int k=0;
    rep(j,1,n){
        int sj=s[j];
        int i=f[j-k-1];
        while(i!=-1 && sj!=s[k+i+1]){
            if(sj<s[k+i+1])k=j-i-1;
            i=f[i];
        }
        if(sj!=s[k+i+1]){
            if(sj<s[k])k=j;
            f[j-k]=-1;
        }
        else{
            f[j-k]=i+1;
        }

    }
    return k;
}

--------------------------------------------------------------------------
Implementation of LONGEST PALINDROMIC SUBSTRING(MANACHER'S)
https://www.geeksforgeeks.org/manachers-algorithm-linear-time-longest-palindromic-substring-part-4/

--------------------------------------------------------------------------
PLAYLISTS
https://www.youtube.com/playlist?list=PLi0ZM-RCX5nvImim3_ilsdLOtDDkOWt-X
https://www.youtube.com/playlist?list=PLixpXjrHOw3YDrcGY1Y6yCAAyuFsmKNZK

--------------------------------------------------------------------------
representation of a number as diff of squares :-https://qr.ae/pNvqR2

--------------------------------------------------------------------------
MO's algorithm on Trees
https://codeforces.com/blog/entry/68271
https://codeforces.com/blog/entry/43230
